# AIL Launcher


from ._config import (
    AIL_DIR_PATH, BUILTINS_MODULE_PATH, CORE_PATH, LIB_PATH, CURRENT_WORK_PATH,
    PY_VERSION_CHECK,
)

# python version check
if PY_VERSION_CHECK:
    from ast import literal_eval
    from sys import version_info, exit
    from .core.version import PY_VERSION_REQUIRE, AIL_VERSION

    verbose, major, minor, easy_checker = PY_VERSION_REQUIRE

    if not easy_checker(
            literal_eval('%s.%s' % (
                version_info.major, version_info.minor))):

        print('Warning: AIL %s require python %s %s, but %s found' % 
              (AIL_VERSION, verbose, '%s.%s' % (major, minor), 
               '%s.%s' % (version_info.major, version_info.minor)))

        exit(1)


import argparse
import os.path
import sys
from importlib import import_module
from .core import shared
from .core import aconfig
from .core.abuiltins import init_builtins
from .core.pyexec import ail_exec
from .core.alex import Lex
from .core.aparser import Parser, ASTConverter
from .core.error import AILSyntaxError

from . import _config


class _Option:
    def __init__(self):
        self.shell_mode = True
        self.filename = ''
        self.rest_args = []
        self.source = False
        self.cmd = None
        self.native_compile = False


# load AIL_PATH in environ
shared.GLOBAL_SHARED_DATA.cwd = CURRENT_WORK_PATH
shared.GLOBAL_SHARED_DATA.ail_path = AIL_DIR_PATH
shared.GLOBAL_SHARED_DATA.boot_dir = os.getcwd()

shared.GLOBAL_SHARED_DATA.find_path = [
     CURRENT_WORK_PATH, BUILTINS_MODULE_PATH, LIB_PATH
]


def parse_arg(args) -> _Option:
    parser = argparse.ArgumentParser(
        'ail', description='AIL Programming Language'
    )
    parser.add_argument('file', nargs='?')
    parser.add_argument(
        '-s', help='dump to python source code', action='store_true',
        dest='source')
    parser.add_argument(
        '-n', help='dump to python source code', action='store_true',
        dest='native')
    parser.add_argument('args', nargs=argparse.REMAINDER)

    namespace = parser.parse_args(args)

    opt = _Option()
    opt.filename = namespace.file
    opt.source = namespace.source
    opt.rest_args = namespace.args
    opt.native_compile = namespace.native
    opt.shell_mode = namespace.file is None

    return opt


def launch_py_test(test_name):
    try:
        mod = import_module('obj_test.%s' % test_name)
        if hasattr(mod, 'test'):
            mod.test()
        else:
            print('Test module do not have \'test\' function!')
    except ModuleNotFoundError:
        print('No test named \'%s\'' % test_name)


def _launch_main(argv: list) -> int:
    init_builtins()

    option = parse_arg(argv)
    # print(option.filename, option.source, option.rest_args)

    option.rest_args.insert(0, option.filename)
    shared.GLOBAL_SHARED_DATA.prog_argv = option.rest_args
    sys.argv = option.rest_args

    if option is None:
        return 1

    if option.shell_mode:
        from .core import ashell
        ashell.Shell().run_shell(option.native_compile)
        return 0

    source_mode = option.source
    native_compile = option.native_compile

    file_path = option.filename
    file_dir = os.path.dirname(
                os.path.normpath(
                    os.path.abspath(file_path)))

    shared.GLOBAL_SHARED_DATA.find_path.insert(0, file_dir)

    try:
        if option.cmd is None and not os.path.exists(file_path):
            raise FileNotFoundError('file \'%s\' not found' % file_path)

        if option.cmd is not None:
            source = option.cmd
            file_path = '<string>'
        else:
            source = open(file_path, encoding='UTF-8').read()

        if not source_mode:
            return ail_exec(source, file_path, dict(), compiler=int(native_compile)+1)

        ast = Parser().parse(Lex().lex(source), source, file_path, source_mode)

        if source_mode:
            try:
                import astunparse

                from .core.version import AIL_VERSION, AIL_VERSION_STATE

                print('# file: %s' % file_path)
                print('# AST generated by AIL ASTConverter')
                print('# code generated by astunparse')
                print('# AIL %s' % AIL_VERSION)
                print()
                print(astunparse.unparse(ASTConverter().convert_module(ast)))
                return 0
            except (ModuleNotFoundError, ImportError):
                print('AIL: require module \'astunparse\'')
                return 1

    except FileNotFoundError as e:
        print('AIL: can\'t open file \'%s\': %s' % (file_path, str(e)))
        return 1


def launch_main(argv: list):
    try:
        return _launch_main(argv)
    except AILSyntaxError as e:
        print(e.raw_msg, file=sys.stderr)
    except SystemExit:
        return 0


if __name__ == '__main__':
    sys.exit(launch_main(sys.argv[1:]))

