# PyASM

> 2022 / 12 / 28

**只支持 AIL 3.0 及以上的版本，需要开启自编译模式**

PyASM 是 AIL 中的一个较为高级的特性，它允许开发者直接在 AIL 程序中嵌入 cpython 字节码。由于 PyASM 在编译期间并不会进行任何的语义分析，在 PyASM 中对所有变量的引用和赋值均不会追踪。同时，由于没有栈分析，错误的 PyASM 操作可能会导致程序的崩溃。


## cpython 字节码基本介绍

想要使用 PyASM，必须要对 cpython 字节码有一定的了解。cpython 字节码是 Python 代码经过 cpython 编译器生成的字节指令序列，最终 cpython 虚拟机将读取并执行这些指令序列，这也是 Python 程序执行的流程（对于 cpython 而言）。

cpython 的虚拟机是基于栈的虚拟机，自然而然地，对应的字节码也是基于栈进行操作的。在 cpython 程序执行的过程中，有十分频繁的栈操作。所以说，在编写 PyASM 的过程中，要时刻注意栈的状态。

### cpython 字节码执行流程

下面是一个简单的 AIL 代码段：

```python
greeting = 'Hello %s!';
who = 'Klee';
print greeting % who;
```

这段代码对应的字节码如下：

```
0	LOAD_CONST      0
2	STORE_NAME      0
4	LOAD_CONST      1
6	STORE_NAME      1
8	LOAD_GLOBAL     2
10 	LOAD_NAME       0
12	LOAD_NAME       1
14	BINARY_MODULO
16	CALL_FUNCTION   1
18	POP_TOP
```

这是一段非常简单的字节码指令序列，它是线性的，全程没有控制流的影响。cpython 虚拟机从头开始执行每一条指令，直到末尾。在执行过程中，虚拟机会为当前的上下文创建一个帧 `Frame` ，在帧中会初始化一个栈，执行指令时操作的就是这个栈。例如上面的这段字节码执行的流程如下：

*将字面量元组的第0项压入栈中；弹出栈顶，将其存储到名称为名称元组的第0项的变量；将字面量元组的第1项压入栈中；弹出栈顶，将其存储到名称为名称元组的第1项的变量；从全局名称空间中加载名称元组第2项的名字并将其压入栈中；加载名称为名称元组第0项的变量；加载名称为名称元组第1项的变量；弹出栈顶两项，做模运算，将结果压入栈中；弹出栈顶2项（1个参数和1个函数）进行函数调用操作，将返回值压入栈中；丢弃栈顶。*

可以看出，在整个过程中，离不开对栈的操作。

有关 cpython 字节码的更多内容，可以查看 cpython 的[官方文档](https://docs.python.org/zh-cn/3.8/library/dis.html) 。

## 语法

PyASM 的语法如下：

```
pyasm_expr := '%' [pyasm_single | pyasm_group]
pyasm_single := NAME ['(' [NUMBER | STRING] [',' NUMBER]? ')']?
pyasm_group := '(' pyasm_single* ')'
```

根据语法，下列的形式都是合法的：

```
%load_const(10)

%pop_top

%call_function(1, -1)

%(
    load_const(1)
    load_const(2)
    binary_add
    pop_top
)

%()
```

## 结构

单条 PyASM 有如下三种不同的结构：

```
% 指令名称
% 指令名称 (参数)
% 指令名称 (参数, 栈改变量)
```

#### % 指令名称

这是最基本的结构，在不提供参数和栈改变量的情况下，参数默认为 0，栈改变量将视情况自行计算，如果栈改变量需要显式指定或提供了错误的栈改变量值，则会抛出一个错误。

#### % 指令名称 (参数)

显式指定参数，栈改变量将视情况自行计算，如果栈改变量需要显式指定或提供了错误的栈改变量值，则会抛出一个错误。

#### % 指令名称 (参数, 栈改变量)

所有部分都自行指定。如果栈改变量需要显式指定或提供了错误的栈改变量值，则会抛出一个错误。

#### 指令名称

指令名称是对应字节码的助记符，不区分大小写，因此 `LOAD_CONST` 和 `load_const` 是等价的。

#### 参数

提供给指令的参数，不同指令有不同的参数，也有的指令没有参数，当指令不需要参数时，不会进行参数检查。当指令需要参数时，则需要传入正确的参数类型。PyASM 支持 3 种参数类型: `str` , `float` , `int` 。**不当的参数传递可能会导致程序崩溃。**

#### 栈改变量

该指令从开始到结束执行时，栈深度的改变量。规定若从栈中弹出 a 个元素，压入 b 个元素，则栈改变量为 b - a，例如 `binary_add` 指令执行的过程将从栈中弹出两个元素，压入一个元素，则它的栈改变量为 -1，对于 `binary_` 系列的指令，由于栈改变量是固定的，所以不需要显式指定。而对于 `call_function` 这类指令，就需要显式提供了。
