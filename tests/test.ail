begin

load 'types'

struct list_t is
    _ele
    size
end

fun _check_t(o) is
    return isinstance(o, list_t)
end

fun List() is
    lo = new(list_t, {{}, 0})

    return lo
end

fun _copy_new(elen, eleo) is
    // copy old element list to new element list

    i = 0
    while i < len(eleo) then
        elen[i] = eleo[i]
        i = i + 1
    wend
end

/*
 * lapped(list_t a, any o)
 * append o to the end of a
 */
fun lappend(a, o) is
    if not _check_t(a) then
        return null
    endif

    eleo = a._ele
    a._ele = array(a.size + 1)

    _copy_new(a._ele, eleo)
    a._ele[-1] = o

    a.size = a.size + 1

    return true
end

/*
 * lremove(list_t a, int index)
 * remove the object at 'index'
 */
fun lremove(a, index) is
    print a
    if not _check_t(a) or index >= len(a._ele) then
        return null
    endif

    // 从 index 处切割，然后再覆盖
    i = 0
    left = array(index)

    while i < index then  // 填充 left
        left[i] = a._ele[i]
        i = i + 1
    wend

    new_a = array(len(a._ele) - 1)
    
    i = 0
    while i < len(left) then
        new_a[i] = left[i]
        i = i + 1
    wend
    
    i = index + 1
    ni = 0
    while ni < len(new_a) and i < len(a._ele) then
        new_a[ni] = a._ele[i]
        i = i + 1
        ni = ni + 1
    wend

    a._ele = new_a
    a.size = a.size - 1

    return true
end


/*
 * lto_str(list_t a)
 * return the string form of a.
 */
fun lto_str(a) is
    if not _check_t(a) then
        return null
    endif

    return str(a._ele)
end

l = List()
lappend(l, 'nz')
lremove(l, 0)

print(lto_str(l))

end
